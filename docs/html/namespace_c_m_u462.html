<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Asst3: PathTracer: CMU462 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Asst3: PathTracer
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">15-462/15-662: Computer Graphics (Fall 2015)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CMU462 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A MutablePriorityQueue is a minimum-priority queue that allows elements to be both inserted and removed from the queue.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_m_u462_1_1_b_box.html">BBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned bounding box.  <a href="struct_c_m_u462_1_1_b_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_camera.html">Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Camera.  <a href="class_c_m_u462_1_1_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Face is a single polygon in the mesh.  <a href="class_c_m_u462_1_1_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_halfedge.html">Halfedge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Halfedge is the basic "glue" between mesh elements, pointing to its associated vertex, edge, and face, as will as its twin and next halfedges.  <a href="class_c_m_u462_1_1_halfedge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_halfedge_element.html">HalfedgeElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HalfedgeElement is the base type for all mesh elements (halfedges, vertices, edges, and faces).  <a href="class_c_m_u462_1_1_halfedge_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_image_buffer.html">ImageBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a mutable image which uses 8-bit RGBA pixel layout.  <a href="class_c_m_u462_1_1_image_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_path_tracer.html">PathTracer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pathtracer with BVH accelerator and BVH visualization capabilities.  <a href="class_c_m_u462_1_1_path_tracer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_sampler2_d.html">Sampler2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for generating point samples within the unit square.  <a href="class_c_m_u462_1_1_sampler2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_sampler3_d.html">Sampler3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for generating 3D vector samples.  <a href="class_c_m_u462_1_1_sampler3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_uniform_grid_sampler2_d.html">UniformGridSampler2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Sampler2D implementation with uniform distribution on unit square.  <a href="class_c_m_u462_1_1_uniform_grid_sampler2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_uniform_hemisphere_sampler3_d.html">UniformHemisphereSampler3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Sampler3D implementation with uniform distribution on unit hemisphere.  <a href="class_c_m_u462_1_1_uniform_hemisphere_sampler3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_u462_1_1_vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vertex encodes one of the mesh vertices.  <a href="class_c_m_u462_1_1_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a935af910bd1a69423f64fdc858b30f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_m_u462_1_1_halfedge.html">Halfedge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_m_u462.html#a935af910bd1a69423f64fdc858b30f45">elementAddress</a> (HalfedgeIter h)</td></tr>
<tr class="memdesc:a935af910bd1a69423f64fdc858b30f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The elementAddress() function is defined only for convenience (and readability), and returns the actual memory address associated with a mesh element referred to by the given iterator.  <a href="#a935af910bd1a69423f64fdc858b30f45">More...</a><br /></td></tr>
<tr class="separator:a935af910bd1a69423f64fdc858b30f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5618d95d83e2025fab0e90b7f0a94263"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5618d95d83e2025fab0e90b7f0a94263"></a>
<a class="el" href="class_c_m_u462_1_1_halfedge.html">Halfedge</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_c_m_u462.html#a5618d95d83e2025fab0e90b7f0a94263">elementAddress</a> (HalfedgeCIter h)</td></tr>
<tr class="memdesc:a5618d95d83e2025fab0e90b7f0a94263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same thing, just for constant references. <br /></td></tr>
<tr class="separator:a5618d95d83e2025fab0e90b7f0a94263"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A MutablePriorityQueue is a minimum-priority queue that allows elements to be both inserted and removed from the queue. </p>
<p>Together, one can easily change the priority of an item by removing it, and re-inserting the same item but with a different priority. A priority queue, for those who don't remember or haven't seen it before, is a data structure that always keeps track of the item with the smallest priority or "score," even as new elements are inserted and removed. Priority queues are often an essential component of greedy algorithms, where one wants to iteratively operate on the current "best" element.</p>
<p>MutablePriorityQueue is templated on the type T of the object being queued. For this reason, T must define a comparison operator of the form</p>
<p>bool operator&lt;( const T&amp; t1, const T&amp; t2 )</p>
<p>which returns true if and only if t1 is considered to have a lower priority than t2.</p>
<p>Basic use of a MutablePriorityQueue might look something like this:</p>
<p>// initialize an empty queue MutablePriorityQueue&lt;myItemType&gt; queue;</p>
<p>// add some items (which we assume have been created // elsewhere, each of which has its priority stored as // some kind of internal member variable) queue.insertItem( item1 ); queue.insertItem( item2 ); queue.insertItem( item3 );</p>
<p>// get the highest priority item currently in the queue myItemType highestPriorityItem = queue.top();</p>
<p>// remove the highest priority item, automatically // promoting the next-highest priority item to the top queue.pop();</p>
<p>myItemType nextHighestPriorityItem = queue.top();</p>
<p>// Etc.</p>
<p>// We can also remove an item, making sure it is no // longer in the queue (note that this item may already // have been removed, if it was the 1st or 2nd-highest // priority item!) queue.remove( item2 ); </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a935af910bd1a69423f64fdc858b30f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_u462_1_1_halfedge.html">Halfedge</a>* CMU462::elementAddress </td>
          <td>(</td>
          <td class="paramtype">HalfedgeIter&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The elementAddress() function is defined only for convenience (and readability), and returns the actual memory address associated with a mesh element referred to by the given iterator. </p>
<p>(This is especially helpful for things like debugging, where we want to check that one element is properly pointing to another.) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 11 2015 03:56:31 for Asst3: PathTracer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
